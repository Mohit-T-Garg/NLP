import re

class PromptGenerator(object):
    def __init__(self):
        """
        Setup generation parameters for Gemma.
        """
        self.output_len = 40
        self.temperature = 0.0
        self.top_p = 1.0
        self.columns = []

    def create_prompt(self, sample):
        """
        Input sample is a dictionary consisting of following fields
        'table': A dict containing table data and meta-data same as in Assignment 2
        'question': A python string for the question on the table.
        
        The function must return the prompt as a python string.
        """
        
        self.question = sample['question']
        
        # Extract column names from the table
        self.columns = [col for col in sample['table']['cols']]

        prompt = """Read the following table and return the row and column of the most probable answer of question. Only return row number and column in the format <CcRr> as in table (without any additional output)."""

        prompt += 'TABLE:\n'
        prompt += ','.join(
            [f'"{cc}"' for cc in sample['table']['cols']]
        ) + '\n'
        for r, row in enumerate(sample['table']['rows']):
            prompt += ','.join(
                [f'<C{c}R{r}> "{rr}"' for c, rr in enumerate(row)]
            ) + '\n'
        prompt += '\n'
        prompt += 'QUESTION: ' + sample['question'] + '\n'
        prompt += '\n'
        prompt += 'NOTE: Please note that the questions typically inquire about a cell in a specific column that meets certain conditions across different columns within the given row. Therefore, choose the column to which the answer belongs.'
        
        return prompt
    
    def post_process(self, text):
        """
        Input gen_text is a python string generated by Gemma for the prompt.
        
        The function must return a single python tuple (int, string)
        indicating the row and the column of the answer cell.
        """
        try:
            # Define the regex pattern
            pattern = r"[Cc](\d+)[Rr](\d+)"

            # Find matches
            matches = re.findall(pattern, text)

            # Extract integers from matches
            if matches:
                
                c = int(matches[0][0])
                r = int(matches[0][1])
                
                return [(r, self.columns[c])]
            
            else:
                
                p1 = r"[Cc](\d+)"
                p2 = r"[Rr](\d+)"
                c = self.columns[0]
                r = 0
                m1 = re.findall(p1, text)
                
                if m1:
                    ci = int(m1[0][0])
                    if ci < len(self.columns):
                        c = self.columns[ci]
                else:
                    for col in self.columns:
                        if col in text:
                            c = col
                            break

                m2 = re.findall(p2, text)
                
                if m2:
                    r = int(m2[0][0])
                return [(r, c)]
            
        except Exception as e:
            
            print("Error occurred:", e)
            return [(0, self.columns[0])]